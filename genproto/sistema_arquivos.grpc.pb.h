// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: sistema_arquivos.proto
#ifndef GRPC_sistema_5farquivos_2eproto__INCLUDED
#define GRPC_sistema_5farquivos_2eproto__INCLUDED

#include "sistema_arquivos.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>
#include <grpcpp/ports_def.inc>

namespace sistemaarquivos {

class SistemaArquivos final {
 public:
  static constexpr char const* service_full_name() {
    return "sistemaarquivos.SistemaArquivos";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status Abre(::grpc::ClientContext* context, const ::sistemaarquivos::AbreRequest& request, ::sistemaarquivos::AbreReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sistemaarquivos::AbreReply>> AsyncAbre(::grpc::ClientContext* context, const ::sistemaarquivos::AbreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sistemaarquivos::AbreReply>>(AsyncAbreRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sistemaarquivos::AbreReply>> PrepareAsyncAbre(::grpc::ClientContext* context, const ::sistemaarquivos::AbreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sistemaarquivos::AbreReply>>(PrepareAsyncAbreRaw(context, request, cq));
    }
    virtual ::grpc::Status Le(::grpc::ClientContext* context, const ::sistemaarquivos::LeRequest& request, ::sistemaarquivos::LeReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sistemaarquivos::LeReply>> AsyncLe(::grpc::ClientContext* context, const ::sistemaarquivos::LeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sistemaarquivos::LeReply>>(AsyncLeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sistemaarquivos::LeReply>> PrepareAsyncLe(::grpc::ClientContext* context, const ::sistemaarquivos::LeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sistemaarquivos::LeReply>>(PrepareAsyncLeRaw(context, request, cq));
    }
    virtual ::grpc::Status Escreve(::grpc::ClientContext* context, const ::sistemaarquivos::EscreveRequest& request, ::sistemaarquivos::EscreveReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sistemaarquivos::EscreveReply>> AsyncEscreve(::grpc::ClientContext* context, const ::sistemaarquivos::EscreveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sistemaarquivos::EscreveReply>>(AsyncEscreveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sistemaarquivos::EscreveReply>> PrepareAsyncEscreve(::grpc::ClientContext* context, const ::sistemaarquivos::EscreveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sistemaarquivos::EscreveReply>>(PrepareAsyncEscreveRaw(context, request, cq));
    }
    virtual ::grpc::Status Fecha(::grpc::ClientContext* context, const ::sistemaarquivos::FechaRequest& request, ::sistemaarquivos::FechaReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sistemaarquivos::FechaReply>> AsyncFecha(::grpc::ClientContext* context, const ::sistemaarquivos::FechaRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sistemaarquivos::FechaReply>>(AsyncFechaRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sistemaarquivos::FechaReply>> PrepareAsyncFecha(::grpc::ClientContext* context, const ::sistemaarquivos::FechaRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::sistemaarquivos::FechaReply>>(PrepareAsyncFechaRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void Abre(::grpc::ClientContext* context, const ::sistemaarquivos::AbreRequest* request, ::sistemaarquivos::AbreReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Abre(::grpc::ClientContext* context, const ::sistemaarquivos::AbreRequest* request, ::sistemaarquivos::AbreReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Le(::grpc::ClientContext* context, const ::sistemaarquivos::LeRequest* request, ::sistemaarquivos::LeReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Le(::grpc::ClientContext* context, const ::sistemaarquivos::LeRequest* request, ::sistemaarquivos::LeReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Escreve(::grpc::ClientContext* context, const ::sistemaarquivos::EscreveRequest* request, ::sistemaarquivos::EscreveReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Escreve(::grpc::ClientContext* context, const ::sistemaarquivos::EscreveRequest* request, ::sistemaarquivos::EscreveReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Fecha(::grpc::ClientContext* context, const ::sistemaarquivos::FechaRequest* request, ::sistemaarquivos::FechaReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Fecha(::grpc::ClientContext* context, const ::sistemaarquivos::FechaRequest* request, ::sistemaarquivos::FechaReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sistemaarquivos::AbreReply>* AsyncAbreRaw(::grpc::ClientContext* context, const ::sistemaarquivos::AbreRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sistemaarquivos::AbreReply>* PrepareAsyncAbreRaw(::grpc::ClientContext* context, const ::sistemaarquivos::AbreRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sistemaarquivos::LeReply>* AsyncLeRaw(::grpc::ClientContext* context, const ::sistemaarquivos::LeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sistemaarquivos::LeReply>* PrepareAsyncLeRaw(::grpc::ClientContext* context, const ::sistemaarquivos::LeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sistemaarquivos::EscreveReply>* AsyncEscreveRaw(::grpc::ClientContext* context, const ::sistemaarquivos::EscreveRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sistemaarquivos::EscreveReply>* PrepareAsyncEscreveRaw(::grpc::ClientContext* context, const ::sistemaarquivos::EscreveRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sistemaarquivos::FechaReply>* AsyncFechaRaw(::grpc::ClientContext* context, const ::sistemaarquivos::FechaRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::sistemaarquivos::FechaReply>* PrepareAsyncFechaRaw(::grpc::ClientContext* context, const ::sistemaarquivos::FechaRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Abre(::grpc::ClientContext* context, const ::sistemaarquivos::AbreRequest& request, ::sistemaarquivos::AbreReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sistemaarquivos::AbreReply>> AsyncAbre(::grpc::ClientContext* context, const ::sistemaarquivos::AbreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sistemaarquivos::AbreReply>>(AsyncAbreRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sistemaarquivos::AbreReply>> PrepareAsyncAbre(::grpc::ClientContext* context, const ::sistemaarquivos::AbreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sistemaarquivos::AbreReply>>(PrepareAsyncAbreRaw(context, request, cq));
    }
    ::grpc::Status Le(::grpc::ClientContext* context, const ::sistemaarquivos::LeRequest& request, ::sistemaarquivos::LeReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sistemaarquivos::LeReply>> AsyncLe(::grpc::ClientContext* context, const ::sistemaarquivos::LeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sistemaarquivos::LeReply>>(AsyncLeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sistemaarquivos::LeReply>> PrepareAsyncLe(::grpc::ClientContext* context, const ::sistemaarquivos::LeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sistemaarquivos::LeReply>>(PrepareAsyncLeRaw(context, request, cq));
    }
    ::grpc::Status Escreve(::grpc::ClientContext* context, const ::sistemaarquivos::EscreveRequest& request, ::sistemaarquivos::EscreveReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sistemaarquivos::EscreveReply>> AsyncEscreve(::grpc::ClientContext* context, const ::sistemaarquivos::EscreveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sistemaarquivos::EscreveReply>>(AsyncEscreveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sistemaarquivos::EscreveReply>> PrepareAsyncEscreve(::grpc::ClientContext* context, const ::sistemaarquivos::EscreveRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sistemaarquivos::EscreveReply>>(PrepareAsyncEscreveRaw(context, request, cq));
    }
    ::grpc::Status Fecha(::grpc::ClientContext* context, const ::sistemaarquivos::FechaRequest& request, ::sistemaarquivos::FechaReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sistemaarquivos::FechaReply>> AsyncFecha(::grpc::ClientContext* context, const ::sistemaarquivos::FechaRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sistemaarquivos::FechaReply>>(AsyncFechaRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sistemaarquivos::FechaReply>> PrepareAsyncFecha(::grpc::ClientContext* context, const ::sistemaarquivos::FechaRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::sistemaarquivos::FechaReply>>(PrepareAsyncFechaRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void Abre(::grpc::ClientContext* context, const ::sistemaarquivos::AbreRequest* request, ::sistemaarquivos::AbreReply* response, std::function<void(::grpc::Status)>) override;
      void Abre(::grpc::ClientContext* context, const ::sistemaarquivos::AbreRequest* request, ::sistemaarquivos::AbreReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Le(::grpc::ClientContext* context, const ::sistemaarquivos::LeRequest* request, ::sistemaarquivos::LeReply* response, std::function<void(::grpc::Status)>) override;
      void Le(::grpc::ClientContext* context, const ::sistemaarquivos::LeRequest* request, ::sistemaarquivos::LeReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Escreve(::grpc::ClientContext* context, const ::sistemaarquivos::EscreveRequest* request, ::sistemaarquivos::EscreveReply* response, std::function<void(::grpc::Status)>) override;
      void Escreve(::grpc::ClientContext* context, const ::sistemaarquivos::EscreveRequest* request, ::sistemaarquivos::EscreveReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Fecha(::grpc::ClientContext* context, const ::sistemaarquivos::FechaRequest* request, ::sistemaarquivos::FechaReply* response, std::function<void(::grpc::Status)>) override;
      void Fecha(::grpc::ClientContext* context, const ::sistemaarquivos::FechaRequest* request, ::sistemaarquivos::FechaReply* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::sistemaarquivos::AbreReply>* AsyncAbreRaw(::grpc::ClientContext* context, const ::sistemaarquivos::AbreRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sistemaarquivos::AbreReply>* PrepareAsyncAbreRaw(::grpc::ClientContext* context, const ::sistemaarquivos::AbreRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sistemaarquivos::LeReply>* AsyncLeRaw(::grpc::ClientContext* context, const ::sistemaarquivos::LeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sistemaarquivos::LeReply>* PrepareAsyncLeRaw(::grpc::ClientContext* context, const ::sistemaarquivos::LeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sistemaarquivos::EscreveReply>* AsyncEscreveRaw(::grpc::ClientContext* context, const ::sistemaarquivos::EscreveRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sistemaarquivos::EscreveReply>* PrepareAsyncEscreveRaw(::grpc::ClientContext* context, const ::sistemaarquivos::EscreveRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sistemaarquivos::FechaReply>* AsyncFechaRaw(::grpc::ClientContext* context, const ::sistemaarquivos::FechaRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::sistemaarquivos::FechaReply>* PrepareAsyncFechaRaw(::grpc::ClientContext* context, const ::sistemaarquivos::FechaRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Abre_;
    const ::grpc::internal::RpcMethod rpcmethod_Le_;
    const ::grpc::internal::RpcMethod rpcmethod_Escreve_;
    const ::grpc::internal::RpcMethod rpcmethod_Fecha_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status Abre(::grpc::ServerContext* context, const ::sistemaarquivos::AbreRequest* request, ::sistemaarquivos::AbreReply* response);
    virtual ::grpc::Status Le(::grpc::ServerContext* context, const ::sistemaarquivos::LeRequest* request, ::sistemaarquivos::LeReply* response);
    virtual ::grpc::Status Escreve(::grpc::ServerContext* context, const ::sistemaarquivos::EscreveRequest* request, ::sistemaarquivos::EscreveReply* response);
    virtual ::grpc::Status Fecha(::grpc::ServerContext* context, const ::sistemaarquivos::FechaRequest* request, ::sistemaarquivos::FechaReply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Abre : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Abre() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Abre() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Abre(::grpc::ServerContext* /*context*/, const ::sistemaarquivos::AbreRequest* /*request*/, ::sistemaarquivos::AbreReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAbre(::grpc::ServerContext* context, ::sistemaarquivos::AbreRequest* request, ::grpc::ServerAsyncResponseWriter< ::sistemaarquivos::AbreReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Le : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Le() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Le() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Le(::grpc::ServerContext* /*context*/, const ::sistemaarquivos::LeRequest* /*request*/, ::sistemaarquivos::LeReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLe(::grpc::ServerContext* context, ::sistemaarquivos::LeRequest* request, ::grpc::ServerAsyncResponseWriter< ::sistemaarquivos::LeReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Escreve : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Escreve() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_Escreve() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Escreve(::grpc::ServerContext* /*context*/, const ::sistemaarquivos::EscreveRequest* /*request*/, ::sistemaarquivos::EscreveReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEscreve(::grpc::ServerContext* context, ::sistemaarquivos::EscreveRequest* request, ::grpc::ServerAsyncResponseWriter< ::sistemaarquivos::EscreveReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Fecha : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Fecha() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_Fecha() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Fecha(::grpc::ServerContext* /*context*/, const ::sistemaarquivos::FechaRequest* /*request*/, ::sistemaarquivos::FechaReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFecha(::grpc::ServerContext* context, ::sistemaarquivos::FechaRequest* request, ::grpc::ServerAsyncResponseWriter< ::sistemaarquivos::FechaReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Abre<WithAsyncMethod_Le<WithAsyncMethod_Escreve<WithAsyncMethod_Fecha<Service > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Abre : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Abre() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::sistemaarquivos::AbreRequest, ::sistemaarquivos::AbreReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sistemaarquivos::AbreRequest* request, ::sistemaarquivos::AbreReply* response) { return this->Abre(context, request, response); }));}
    void SetMessageAllocatorFor_Abre(
        ::grpc::MessageAllocator< ::sistemaarquivos::AbreRequest, ::sistemaarquivos::AbreReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sistemaarquivos::AbreRequest, ::sistemaarquivos::AbreReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Abre() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Abre(::grpc::ServerContext* /*context*/, const ::sistemaarquivos::AbreRequest* /*request*/, ::sistemaarquivos::AbreReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Abre(
      ::grpc::CallbackServerContext* /*context*/, const ::sistemaarquivos::AbreRequest* /*request*/, ::sistemaarquivos::AbreReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Le : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Le() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::sistemaarquivos::LeRequest, ::sistemaarquivos::LeReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sistemaarquivos::LeRequest* request, ::sistemaarquivos::LeReply* response) { return this->Le(context, request, response); }));}
    void SetMessageAllocatorFor_Le(
        ::grpc::MessageAllocator< ::sistemaarquivos::LeRequest, ::sistemaarquivos::LeReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sistemaarquivos::LeRequest, ::sistemaarquivos::LeReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Le() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Le(::grpc::ServerContext* /*context*/, const ::sistemaarquivos::LeRequest* /*request*/, ::sistemaarquivos::LeReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Le(
      ::grpc::CallbackServerContext* /*context*/, const ::sistemaarquivos::LeRequest* /*request*/, ::sistemaarquivos::LeReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Escreve : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Escreve() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::sistemaarquivos::EscreveRequest, ::sistemaarquivos::EscreveReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sistemaarquivos::EscreveRequest* request, ::sistemaarquivos::EscreveReply* response) { return this->Escreve(context, request, response); }));}
    void SetMessageAllocatorFor_Escreve(
        ::grpc::MessageAllocator< ::sistemaarquivos::EscreveRequest, ::sistemaarquivos::EscreveReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sistemaarquivos::EscreveRequest, ::sistemaarquivos::EscreveReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Escreve() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Escreve(::grpc::ServerContext* /*context*/, const ::sistemaarquivos::EscreveRequest* /*request*/, ::sistemaarquivos::EscreveReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Escreve(
      ::grpc::CallbackServerContext* /*context*/, const ::sistemaarquivos::EscreveRequest* /*request*/, ::sistemaarquivos::EscreveReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Fecha : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Fecha() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::sistemaarquivos::FechaRequest, ::sistemaarquivos::FechaReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::sistemaarquivos::FechaRequest* request, ::sistemaarquivos::FechaReply* response) { return this->Fecha(context, request, response); }));}
    void SetMessageAllocatorFor_Fecha(
        ::grpc::MessageAllocator< ::sistemaarquivos::FechaRequest, ::sistemaarquivos::FechaReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::sistemaarquivos::FechaRequest, ::sistemaarquivos::FechaReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Fecha() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Fecha(::grpc::ServerContext* /*context*/, const ::sistemaarquivos::FechaRequest* /*request*/, ::sistemaarquivos::FechaReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Fecha(
      ::grpc::CallbackServerContext* /*context*/, const ::sistemaarquivos::FechaRequest* /*request*/, ::sistemaarquivos::FechaReply* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_Abre<WithCallbackMethod_Le<WithCallbackMethod_Escreve<WithCallbackMethod_Fecha<Service > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Abre : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Abre() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Abre() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Abre(::grpc::ServerContext* /*context*/, const ::sistemaarquivos::AbreRequest* /*request*/, ::sistemaarquivos::AbreReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Le : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Le() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Le() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Le(::grpc::ServerContext* /*context*/, const ::sistemaarquivos::LeRequest* /*request*/, ::sistemaarquivos::LeReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Escreve : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Escreve() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_Escreve() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Escreve(::grpc::ServerContext* /*context*/, const ::sistemaarquivos::EscreveRequest* /*request*/, ::sistemaarquivos::EscreveReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Fecha : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Fecha() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_Fecha() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Fecha(::grpc::ServerContext* /*context*/, const ::sistemaarquivos::FechaRequest* /*request*/, ::sistemaarquivos::FechaReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Abre : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Abre() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Abre() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Abre(::grpc::ServerContext* /*context*/, const ::sistemaarquivos::AbreRequest* /*request*/, ::sistemaarquivos::AbreReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAbre(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Le : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Le() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_Le() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Le(::grpc::ServerContext* /*context*/, const ::sistemaarquivos::LeRequest* /*request*/, ::sistemaarquivos::LeReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLe(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Escreve : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Escreve() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_Escreve() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Escreve(::grpc::ServerContext* /*context*/, const ::sistemaarquivos::EscreveRequest* /*request*/, ::sistemaarquivos::EscreveReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEscreve(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Fecha : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Fecha() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_Fecha() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Fecha(::grpc::ServerContext* /*context*/, const ::sistemaarquivos::FechaRequest* /*request*/, ::sistemaarquivos::FechaReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFecha(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Abre : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Abre() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Abre(context, request, response); }));
    }
    ~WithRawCallbackMethod_Abre() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Abre(::grpc::ServerContext* /*context*/, const ::sistemaarquivos::AbreRequest* /*request*/, ::sistemaarquivos::AbreReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Abre(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Le : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Le() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Le(context, request, response); }));
    }
    ~WithRawCallbackMethod_Le() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Le(::grpc::ServerContext* /*context*/, const ::sistemaarquivos::LeRequest* /*request*/, ::sistemaarquivos::LeReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Le(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Escreve : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Escreve() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Escreve(context, request, response); }));
    }
    ~WithRawCallbackMethod_Escreve() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Escreve(::grpc::ServerContext* /*context*/, const ::sistemaarquivos::EscreveRequest* /*request*/, ::sistemaarquivos::EscreveReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Escreve(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Fecha : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Fecha() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Fecha(context, request, response); }));
    }
    ~WithRawCallbackMethod_Fecha() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Fecha(::grpc::ServerContext* /*context*/, const ::sistemaarquivos::FechaRequest* /*request*/, ::sistemaarquivos::FechaReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Fecha(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Abre : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Abre() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sistemaarquivos::AbreRequest, ::sistemaarquivos::AbreReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sistemaarquivos::AbreRequest, ::sistemaarquivos::AbreReply>* streamer) {
                       return this->StreamedAbre(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Abre() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Abre(::grpc::ServerContext* /*context*/, const ::sistemaarquivos::AbreRequest* /*request*/, ::sistemaarquivos::AbreReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAbre(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sistemaarquivos::AbreRequest,::sistemaarquivos::AbreReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Le : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Le() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sistemaarquivos::LeRequest, ::sistemaarquivos::LeReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sistemaarquivos::LeRequest, ::sistemaarquivos::LeReply>* streamer) {
                       return this->StreamedLe(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Le() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Le(::grpc::ServerContext* /*context*/, const ::sistemaarquivos::LeRequest* /*request*/, ::sistemaarquivos::LeReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLe(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sistemaarquivos::LeRequest,::sistemaarquivos::LeReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Escreve : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Escreve() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sistemaarquivos::EscreveRequest, ::sistemaarquivos::EscreveReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sistemaarquivos::EscreveRequest, ::sistemaarquivos::EscreveReply>* streamer) {
                       return this->StreamedEscreve(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Escreve() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Escreve(::grpc::ServerContext* /*context*/, const ::sistemaarquivos::EscreveRequest* /*request*/, ::sistemaarquivos::EscreveReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEscreve(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sistemaarquivos::EscreveRequest,::sistemaarquivos::EscreveReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Fecha : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Fecha() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::sistemaarquivos::FechaRequest, ::sistemaarquivos::FechaReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::sistemaarquivos::FechaRequest, ::sistemaarquivos::FechaReply>* streamer) {
                       return this->StreamedFecha(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Fecha() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Fecha(::grpc::ServerContext* /*context*/, const ::sistemaarquivos::FechaRequest* /*request*/, ::sistemaarquivos::FechaReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFecha(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::sistemaarquivos::FechaRequest,::sistemaarquivos::FechaReply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Abre<WithStreamedUnaryMethod_Le<WithStreamedUnaryMethod_Escreve<WithStreamedUnaryMethod_Fecha<Service > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Abre<WithStreamedUnaryMethod_Le<WithStreamedUnaryMethod_Escreve<WithStreamedUnaryMethod_Fecha<Service > > > > StreamedService;
};

}  // namespace sistemaarquivos


#include <grpcpp/ports_undef.inc>
#endif  // GRPC_sistema_5farquivos_2eproto__INCLUDED
